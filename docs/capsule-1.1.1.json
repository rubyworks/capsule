{"(metadata)":{"source":["Profile"],"authors":[{"name":"Thomas Sawyer","email":"transfire@gmail.com"},{"name":"Joel VanderWerf"}],"copyrights":[{"holder":"Thomas Sawyer","year":"2007","license":"BSD-2"},{"holder":"Joel VanderWerf","year":"2004","license":"Ruby"}],"replacements":[],"alternatives":[],"requirements":[{"name":"detroit","groups":["build"],"development":true},{"name":"qed","groups":["test"],"development":true}],"dependencies":[],"conflicts":[],"repositories":[{"uri":"git://github.com/rubyworks/capsule.git","scm":"git","name":"upstream"}],"resources":{"home":"http://rubyworks.github.com/capsule","code":"http://github.com/rubyworks/capsule"},"extra":{},"load_path":["lib"],"revision":0,"name":"capsule","title":"Capsule","version":"1.1.1","summary":"Encapsulate Scripts in Modules","created":"2005-01-01","description":"Capsule is subclass of Module. It encapsulates an extenal script as a functions module.","organization":"Rubyworks","date":"2011-10-22","path":"(metadata)","markup":"rdoc"},"Capsule":{"!":"class","superclass":"Module","path":"Capsule","name":"Capsule","namespace":"","comment":"A module which is an instance of the Capsule class encapsulates in its scope\nthe top-level methods, top-level constants, and instance variables defined in\na ruby script file (and its subfiles) loaded by a ruby program. This allows\nuse of script files to define objects that can be loaded into a program in\nmuch the same way that objects can be loaded from YAML or Marshal files.\n\nSee intro.txt[link:files/intro_txt.html] for an overview.","format":"rdoc","constants":["Capsule::SUFFIXES"],"includes":[],"extensions":[],"modules":[],"classes":["Capsule::MissingFile"],"methods":["Capsule#main_file","Capsule#load_path","Capsule#loaded_features","Capsule.load","Capsule#initialize","Capsule#load_path_lookup","Capsule#load","Capsule#require","Capsule#include","Capsule#include_script","Capsule#load_in_module","Capsule#inspect"],"accessors":["Capsule#main_file","Capsule#load_path","Capsule#loaded_features"],"files":["/lib/capsule.rb"],"tags":{}},"Capsule::SUFFIXES":{"!":"constant","path":"Capsule::SUFFIXES","name":"SUFFIXES","namespace":"Capsule","comment":"Ruby script extensions to automatically try when searching for\na script on the load_path.","format":"rdoc","value":"['.rb', '.rbs']","tags":{},"files":["/lib/capsule.rb"]},"Capsule#main_file":{"!":"method","declarations":["instance","public"],"path":"Capsule#main_file","name":"main_file","namespace":"Capsule","comment":"The script file with which the import was instantiated.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"main_file","arguments":[]}],"returns":[],"file":"/lib/capsule.rb","line":23,"source":"def main_file\n  @main_file\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#load_path":{"!":"method","declarations":["instance","public"],"path":"Capsule#load_path","name":"load_path","namespace":"Capsule","comment":"An array of paths to search for scripts. This has the same\nsemantics as <tt>$:</tt>, alias <tt>$LOAD_PATH</tt>, except\nthat it is local to this script. The path of the current\nscript is added automatically.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"load_path","arguments":[]}],"returns":[],"file":"/lib/capsule.rb","line":34,"source":"def load_path\n  @load_path\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#loaded_features":{"!":"method","declarations":["instance","public"],"path":"Capsule#loaded_features","name":"loaded_features","namespace":"Capsule","comment":"A hash that maps <tt>filename=>true</tt> for each file that has been\nrequired locally by the script. This has the same semantics as <tt>$\"</tt>,\nalias <tt>$LOADED_FEATURES</tt>, except that it is local to this script.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"loaded_features","arguments":[]}],"returns":[],"file":"/lib/capsule.rb","line":40,"source":"def loaded_features\n  @loaded_features\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule.load":{"!":"method","declarations":["class","public"],"path":"Capsule.load","name":"load","namespace":"Capsule","comment":"As with #new but will search Ruby's $LOAD_PATH first.\nThis will also try `.rb` extensions, like require does.","format":"rdoc","aliases":[],"singleton":true,"interfaces":[{"signature":"load(.)","arguments":[{"name":"main_file"},{"name":"options","default":"nil"}],"block":{"name":"&block"}}],"returns":[],"file":"/lib/capsule.rb","line":45,"source":"def self.load(main_file, options=nil, &block)\n  file = nil\n  $LOAD_PATH.each do |path|\n    file = File.join(path, main_file)\n    break if file = File.file?(file)\n    break if file = Dir.glob(file + '{' + SUFFIXES.join(',') + '}').first\n  end\n  new(file || main_file, options=nil, &block)\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#initialize":{"!":"method","declarations":["instance","public"],"path":"Capsule#initialize","name":"initialize","namespace":"Capsule","comment":"Creates new Capsule, and loads _main_file_ in the scope of the script. If a\nblock is given, the script is passed to it before loading from the file, and\nconstants can be defined as inputs to the script.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"initialize(main_file, options=nil, &block)","arguments":[{"name":"main_file"},{"name":"options","default":"nil"}],"block":{"name":"&block"}}],"returns":[{"type":"Capsule","comment":"a new instance of Capsule"}],"file":"/lib/capsule.rb","line":59,"source":"def initialize(main_file, options=nil, &block)\n  options ||= {}\n\n  @main_file       = File.expand_path(main_file)\n\n  @load_path       = options[:load_path] || []\n  @loaded_features = options[:loaded_features] || {}\n\n  @extend          = true  # default\n  @extend          = options[:extend] if options.key?(:extend)\n\n  ## add script's path to load_path\n  ## TODO: should we be doing this?\n  @load_path |= [File.dirname(@main_file)]\n\n  ## if @extend (the default) module extends itself\n  extend self if @extend\n\n  module_eval(&block) if block\n\n  load_in_module(main_file)\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#load_path_lookup":{"!":"method","declarations":["instance","public"],"path":"Capsule#load_path_lookup","name":"load_path_lookup","namespace":"Capsule","comment":"Lookup feature in load path.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"load_path_lookup(feature)","arguments":[{"name":"feature"}]}],"returns":[],"file":"/lib/capsule.rb","line":84,"source":"def load_path_lookup(feature)\n  paths = File.join('{' + @load_path.join(',') + '}', feature + '{' + SUFFIXES + '}')\n  files = Dir.glob(paths)\n  match = files.find{ |f| ! @loaded_features.include?(f) }\n  return match\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#load":{"!":"method","declarations":["instance","public"],"path":"Capsule#load","name":"load","namespace":"Capsule","comment":"Loads _file_ into the capsule. Searches relative to the local dir, that is,\nthe dir of the file given in the original call to\n<tt>Capsule.load(file)</tt>, loads the file, if found, into this Capsule's\nscope, and returns true. If the file is not found, falls back to\n<tt>Kernel.load</tt>, which searches on <tt>$LOAD_PATH</tt>, loads the file,\nif found, into global scope, and returns true. Otherwise, raises\n<tt>LoadError</tt>.\n\nThe _wrap_ argument is passed to <tt>Kernel.load</tt> in the fallback case,\nwhen the file is not found locally.\n\nTypically called from within the main file to load additional sub files, or\nfrom those sub files.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"load(file, wrap = false)","arguments":[{"name":"file"},{"name":"wrap","default":"false"}]}],"returns":[],"file":"/lib/capsule.rb","line":105,"source":"def load(file, wrap = false)\n  file = load_path_lookup(feature)\n  return super unless file\n  load_in_module(file) #File.join(@dir, file))\n  true\nrescue MissingFile\n  super\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#require":{"!":"method","declarations":["instance","public"],"path":"Capsule#require","name":"require","namespace":"Capsule","comment":"Analogous to <tt>Kernel#require</tt>. First tries the local dir, then falls\nback to <tt>Kernel#require</tt>. Will load a given _feature_ only once.\n\nNote that extensions (*.so, *.dll) can be required in the global scope, as\nusual, but not in the local scope. (This is not much of a limitation in\npractice--you wouldn't want to load an extension more than once.) This\nimplementation falls back to <tt>Kernel#require</tt> when the argument is an\nextension or is not found locally.\n\n--\nTODO: Should this be using #include_script instead?\n++","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"require(feature)","arguments":[{"name":"feature"}]}],"returns":[],"file":"/lib/capsule.rb","line":127,"source":"def require(feature)\n  file = load_path_lookup(feature)\n  return super unless file\n  begin\n    @loaded_features[file] = true\n    load_in_module(file)\n  rescue MissingFile\n    @loaded_features[file] = false\n    super\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#include":{"!":"method","declarations":["instance","public"],"path":"Capsule#include","name":"include","namespace":"Capsule","comment":"Checks the class of each +mods+. If a String, then calls #include_script,\notherwise behaves like normal #include.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"include(*mods)","arguments":[{"name":"*mods"}]}],"returns":[],"file":"/lib/capsule.rb","line":142,"source":"def include(*mods)\n  mods.reverse_each do |mod|\n    case mod\n    when String\n      include_script(mod)\n    else\n      super(mod)\n      extend self if @extend\n    end\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#include_script":{"!":"method","declarations":["instance","public"],"path":"Capsule#include_script","name":"include_script","namespace":"Capsule","comment":"Create a new Capsule for a script and include it into the current capsule.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"include_script(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/capsule.rb","line":156,"source":"def include_script(file)\n  include self.class.new(file, :load_path=>load_path, :loaded_features=>loaded_features, :extend=>false)\nrescue Errno::ENOENT => e\n  if /#{file}$/ =~ e.message\n    raise MissingFile, e.message\n  else\n    raise\n  end\n  extend self if @extend\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#load_in_module":{"!":"method","declarations":["instance","public"],"path":"Capsule#load_in_module","name":"load_in_module","namespace":"Capsule","comment":"Loads _file_ in this module's context. Note that <tt>\\_\\_FILE\\_\\_</tt> and\n<tt>\\_\\_LINE\\_\\_</tt> work correctly in _file_.\nCalled by #load and #require; not normally called directly.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"load_in_module(file)","arguments":[{"name":"file"}]}],"returns":[],"file":"/lib/capsule.rb","line":171,"source":"def load_in_module(file)\n  module_eval(IO.read(file), File.expand_path(file))\nrescue Errno::ENOENT => e\n  if /#{file}$/ =~ e.message\n    raise MissingFile, e.message\n  else\n    raise\n  end\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule#inspect":{"!":"method","declarations":["instance","public"],"path":"Capsule#inspect","name":"inspect","namespace":"Capsule","comment":"Give inspection of Capsule with script file name.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"inspect()","arguments":[]}],"returns":[],"file":"/lib/capsule.rb","line":183,"source":"def inspect # :nodoc:\n  \"#<#{self.class}:#{main_file}>\"\nend","language":"ruby","dynamic":true,"tags":{}},"Capsule::MissingFile":{"!":"class","superclass":"LoadError","path":"Capsule::MissingFile","name":"MissingFile","namespace":"Capsule","comment":"Raised by #load_in_module, caught by #load and #require.","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/capsule.rb"],"tags":{}},"Module":{"!":"class","superclass":"Object","path":"Module","name":"Module","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":[],"accessors":[],"files":["/lib/capsule/autoimport.rb"],"tags":{}},"Kernel":{"!":"module","path":"Kernel","name":"Kernel","namespace":"","comment":"","format":"rdoc","constants":[],"includes":[],"extensions":[],"modules":[],"classes":[],"methods":["Kernel#autoimport"],"accessors":[],"files":["/lib/capsule/autoimport.rb"],"tags":{}},"Kernel#autoimport":{"!":"method","declarations":["instance","public"],"path":"Kernel#autoimport","name":"autoimport","namespace":"Kernel","comment":"When the constant named by symbol +mod+ is referenced, loads the script\nin filename using Capsule.load and defines the constant to be equal to the\nresulting Capsule module.\n\nUse like Module#autoload. However, the underlying opertation is #load rather\nthan #require, because scripts, unlike libraries, can be loaded more than\nonce. See examples/autoscript-example.rb.\n\nThis method call `Object.autoimport` as defined in Module.","format":"rdoc","aliases":[],"singleton":false,"interfaces":[{"signature":"autoimport(mod, file)","arguments":[{"name":"mod"},{"name":"file"}]}],"returns":[],"file":"/lib/capsule/autoimport.rb","line":40,"source":"def autoimport(mod, file)\n  Object.autoimport(mod, file)\nend","language":"ruby","dynamic":true,"tags":{}},"/README.rdoc":{"!":"document","path":"README.rdoc","name":"README.rdoc","mtime":"2011-10-22 02:09:39 -0400","text":"= Capsule\n\n\n== Description\n\nCapsule is a subclass of Module. A module which is an instance of the Capsule\nclass encapsulates in its scope the top-level methods, top-level constants, and\ninstance variables defined in a Ruby script (and its dependent files)\nloaded by a Ruby program. This allows use of script files to define objects that\ncan be loaded into a program in much the same way that objects can be loaded\nfrom YAML or Marshaled files. There is also an autoimport method which functions\nlike Ruby's autoload but based on is Capsule.load.\n\n\n== Resources\n\n* home: http://rubyworks.github.com/capsule\n* work: http://github.com/rubyworks/capsule\n* mail: http://groups.google.com/group/rubyworks-mailinglist\n\n\n== Synopsis\n\nTo encapsulate a script in a Capsule:\n\n  myscript = Capsule.new('myscript.rb')\n\nIf the script is in Ruby's $LOAD_PATH, then you can use +Capsule.load+.\n\n  myscript = Capsule.load('myscript.rb')\n\nHere is an example:\n\n  # myscript.rb\n\n  VALUE = [1,2,3]\n\n  def run\n    puts \"#{self} is running.\"\n  end\n\nAnd the encapsulating program:\n\n  # program.rb:\n\n  require 'capsule'\n\n  myscript = Capsule.load(\"myscript.rb\")\n\n  p myscript::VALUE\n\n  myscript.run\n\nRunning `program.rb` will result in:\n\n  $ ruby program.rb\n  [1, 2, 3]\n  #<Capsule:myscript.rb> is running.\n\n\n== Usage\n\nCapsule modules are instantiated with <tt>Capsule.new(main_file)</tt> or the alias\n<tt>Capsule.load(main_file)</tt>. All the top-level constants and top-level\nmethods that are defined in the +main_file+ and its dependent local files (see\nbelow) are scoped in the same Capsule module, and are thereby available to the\ncalling program.\n\nThe +main_file+ can load or require other files with +load+ and +require+, as\nusual. These methods, in the Capsule context, add some behavior to the +Kernel+\n+load+ and +require+ methods: <tt>Capsule#load</tt> and <tt>Capsule#require</tt>\nfirst search for files relative to the +main_file+'s dir. Files loaded in this\nway (\"dependent local files\") are treated like the script file itself: top-level\ndefinitions are added to the script module that is returned by +load+ or\n+require+.\n\nBoth <tt>Capsule#load</tt> and <tt>Capsule#require</tt> fall back to the Kernel\nversions if the file is not found locally. Hence, other ruby libraries can be\nloaded and required as usual, assuming their names do not conflict with local\nfile names. Definitions from those files go into the usual scope (typically\nglobal). The normal ruby +load+ and +require+ behavior can be forced by calling\n<tt>Kernel.load</tt> and <tt>Kernel.require</tt>.\n\nA Capsule immitates the way the top-level ruby context works, so a ruby file that\nwas originally intended to be run from the top level, defining top-level\nconstants and top-level methods, can also be run as a Capsule, and its top-level\nconstants and top-level methods are wrapped in the script's scope. The\ndifference between this behavior and simply wrapping the loaded definitions in\nan _anonymous_ module using <tt>Kernel.load(main_file, true)</tt> is that the\ntop-level methods and top-level constants defined in the script are accessible\nusing the Capsule instance.\n\nThe top-level definitions of a Capsule can be accessed after it has been\nloaded, as follows:\n\n<tt>capsule.meth</tt>\n\n- Call a method defined using <tt>def meth</tt> or <tt>def self.meth</tt> in\n  the script file.\n\n<tt>capsule::K</tt>\n\n- Access a class, module, or constant defined using <tt>K = val</tt> in the\n  script file.\n\nAn \"input\" can be passed to the script before loading. Simply call Capsule.new\n(or Capsule.load) with a block. The block is passed a single argument, the\nCapsule module, and executed before the files are loaded into the Capsule's\nscope. Setting a constant in this block makes the constant available to the\nscript during loading. For example:\n\n  script = Capsule.load(\"my-script.rb\") { |capsule| capsule::INPUT = 3 }\n\nNote that all methods defined in the script file are both instance methods of\nthe module and methods of the module instance (the effect of\n<tt>Module#module_function</tt>). So <tt>include</tt>-ing a Capsule module in a\nclass will give instances of the class all the methods and constants defined in\nthe script, and they will reference the instance's instance variables,\nrather than the Capsule module's instance variables.\n\nThe Capsule class was inspired by Nobu Nokada's suggestion in\nhttp://ruby-talk.org/62727, in a thread (started in http://ruby-talk.org/62660)\nabout how to use ruby script files as specifications of objects.\n\n\n== Installation\n\nTo install with RubyGems simply open a console and type:\n\n  gem install capsule\n\nLocal installation requires Setup.rb (gem install setup),\nthen download the tarball package and type:\n\n  tar -xvzf capsule-1.0.0.tgz\n  cd capsule-1.0.0\n  sudo setup.rb all\n\nWindows users use 'ruby setup.rb all'.\n\n\n== Legal\n\n(FreeBSD License)\n\nCopyright (c) 2007 Thomas Sawyer\n\nUnless otherwise agreed upon by the copyright holder, this program is\nditributed under the terms of the BSD-2-Clause license.\n\nCapsule is based on Joel VanderWerf's Script library.\n\nCopyright (c) 2004 Joel VanderWerf\n\nSee COPYING.rdoc file for details.\n","format":"text/rdoc"},"/HISTORY.rdoc":{"!":"document","path":"HISTORY.rdoc","name":"HISTORY.rdoc","mtime":"2011-10-22 09:15:53 -0400","text":"= RELEASE HISTORY\n\n== 1.1.1 / 2011-10-22\n\nCapsule is now released under the BSD-2-Clause license. Other than that,\nthis release is just an administrative update, bringing the project\nuptodate with the latest build tools. The functionality of the library\nitself has not changed.\n\nChanges:\n\n* Switch to BSD-2-Clause license.\n* Modernize project for latest build tools.\n\n\n== 1.1.0 / 2011-05-12\n\nThis release makes two small enhancements to the Capsule class.\nIt will automatically try `.rb` extension of script names that\nlack an extension and it now provides an `:extend` option which\ncan be set to `false` to deactive a capsules sef extension\n(`extend self`).\n\nChanges:\n\n* Search for scripts with  common ruby extensions.\n* Add :extend option to control self extension.\n\n\n== 1.0.0 / 2009-07-01\n\nThis is the initial stand-alone release of Capsule,\nspun-off from Ruby Facets.\n\nChanges:\n\n* 1 Major Enhancement\n\n  * Happy Birthday!\n\n","format":"text/rdoc"},"/SPEC.rdoc":{"!":"document","path":"SPEC.rdoc","name":"SPEC.rdoc","mtime":"2011-10-22 09:17:25 -0400","text":"= Capsule Example\n\nLet's say we have a Ruby script called 'hello.rb':\n\n  def hello\n    \"HELLO!\"\n  end\n\nWe can load that script into a Capsule and have direct access \nto the #hello method.\n\n  Hello = Capsule.new('hello.rb')\n\n  Hello.hello #=> \"HELLO!\"\n\nBy default, capsules are self extendind (`extend self`), which is\nwhy the above method become accessible. This behavior can be tured\noff by passing a `extend=>false` option to the #new method.\n\n  Hello2 = Capsule.new('hello.rb', :extend=>false)\n\n  expect NoMethodError do\n    Hello2.hello\n  end\n\nWithout automatic self extension, the capsule still has access to all the\nclasses, modules, constants and explicitly defined class methods of the \nloaded script.\n\n\n","format":"text/rdoc"},"/COPYING.rdoc":{"!":"document","path":"COPYING.rdoc","name":"COPYING.rdoc","mtime":"2011-10-22 01:57:17 -0400","text":"= COPYRIGHT NOTICES\n\n== Capsule - Copyright (c) 2007 Thomas Sawyer\n\nPROJECT:: Capsule\nWEBSITE:: http://rubyworks.github.com/capsule\nLICENSE:: BSD 2 Clause License\n\n    Copyright (c) 2007 Thomas Sawyer\n\n    Redistribution and use in source and binary forms, with or without modification, are\n    permitted provided that the following conditions are met:\n\n       1. Redistributions of source code must retain the above copyright notice, this list of\n          conditions and the following disclaimer.\n\n       2. Redistributions in binary form must reproduce the above copyright notice, this list\n          of conditions and the following disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND ANY EXPRESS OR IMPLIED\n    WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n    FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR\n    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n    ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n    The views and conclusions contained in the software and documentation are those of the\n    authors and should not be interpreted as representing official policies, either expressed\n    or implied, of <copyright holder>.\n\n\n== Script - Copyright (c) 2004 Joel VanderWerf\n\nPROJECT:: Script\nWEBSITE:: http://redshift.sourceforge.net/script/\nLICENSE:: Ruby License\n\n    Capsule is a derivation of Joel VanderWerf's Script library.\n\n    Usable under the Ruby license. \n\n    Questions to mailto:vjoel@users.sourceforge.net.\n\n","format":"text/rdoc"},"/lib/capsule/autoimport.rb":{"!":"script","path":"lib/capsule/autoimport.rb","name":"autoimport.rb","mtime":"2011-05-15 16:52:26 -0400","source":"class Module\n\n  const_missing_definition_for_autoimport = lambda do\n    #$autoimport_activated = true\n    alias const_missing_before_autoimport const_missing\n\n    def const_missing(sym) # :nodoc:\n      filename = @autoimport && @autoimport[sym]\n      if filename\n        mod = Capsule.load(filename)\n        const_set sym, mod\n      else\n        const_missing_before_autoimport(sym)\n      end\n    end\n  end\n\n  # See Kernel#autoimport.\n  #\n  # TODO: Document this method using meta-programming markup.\n  define_method(:autoimport) do |mod, file|\n    if @autoimport.empty? #unless $autoimport_activated\n      const_missing_definition_for_autoimport.call\n    end\n    (@autoimport ||= {})[mod] = file\n  end\nend\n\n\nmodule Kernel\n  # When the constant named by symbol +mod+ is referenced, loads the script\n  # in filename using Capsule.load and defines the constant to be equal to the\n  # resulting Capsule module.\n  #\n  # Use like Module#autoload. However, the underlying opertation is #load rather\n  # than #require, because scripts, unlike libraries, can be loaded more than\n  # once. See examples/autoscript-example.rb.\n  #\n  # This method call `Object.autoimport` as defined in Module.\n  def autoimport(mod, file)\n    Object.autoimport(mod, file)\n  end\nend\n\n","language":"text/x-ruby"},"/lib/capsule.rb":{"!":"script","path":"lib/capsule.rb","name":"capsule.rb","mtime":"2011-05-12 10:57:33 -0400","source":"#require 'rbconfig'\nrequire 'capsule/autoimport'\n\n# A module which is an instance of the Capsule class encapsulates in its scope\n# the top-level methods, top-level constants, and instance variables defined in\n# a ruby script file (and its subfiles) loaded by a ruby program. This allows\n# use of script files to define objects that can be loaded into a program in\n# much the same way that objects can be loaded from YAML or Marshal files.\n#\n# See intro.txt[link:files/intro_txt.html] for an overview.\n#\nclass Capsule < Module\n\n  #DLEXT = Config::CONFIG['DLEXT']\n\n  # Ruby script extensions to automatically try when searching for\n  # a script on the load_path.\n\n  SUFFIXES = ['.rb', '.rbs'] #, '.rbw', '.so', '.bundle', '.dll', '.sl', '.jar']\n\n  # The script file with which the import was instantiated.\n\n  attr_reader :main_file\n\n  # The directory in which main_file is located, and relative to which\n  # #load searches for files before falling back to Kernel#load.\n  #attr_reader :dir\n\n  # An array of paths to search for scripts. This has the same\n  # semantics as <tt>$:</tt>, alias <tt>$LOAD_PATH</tt>, except\n  # that it is local to this script. The path of the current\n  # script is added automatically.\n\n  attr_reader :load_path\n\n  # A hash that maps <tt>filename=>true</tt> for each file that has been\n  # required locally by the script. This has the same semantics as <tt>$\"</tt>,\n  # alias <tt>$LOADED_FEATURES</tt>, except that it is local to this script.\n\n  attr_reader :loaded_features\n\n  # As with #new but will search Ruby's $LOAD_PATH first.\n  # This will also try `.rb` extensions, like require does.\n\n  def self.load(main_file, options=nil, &block)\n    file = nil\n    $LOAD_PATH.each do |path|\n      file = File.join(path, main_file)\n      break if file = File.file?(file)\n      break if file = Dir.glob(file + '{' + SUFFIXES.join(',') + '}').first\n    end\n    new(file || main_file, options=nil, &block)\n  end\n\n  # Creates new Capsule, and loads _main_file_ in the scope of the script. If a\n  # block is given, the script is passed to it before loading from the file, and\n  # constants can be defined as inputs to the script.\n\n  def initialize(main_file, options=nil, &block)\n    options ||= {}\n\n    @main_file       = File.expand_path(main_file)\n\n    @load_path       = options[:load_path] || []\n    @loaded_features = options[:loaded_features] || {}\n\n    @extend          = true  # default\n    @extend          = options[:extend] if options.key?(:extend)\n\n    ## add script's path to load_path\n    ## TODO: should we be doing this?\n    @load_path |= [File.dirname(@main_file)]\n\n    ## if @extend (the default) module extends itself\n    extend self if @extend\n\n    module_eval(&block) if block\n\n    load_in_module(main_file)\n  end\n\n  # Lookup feature in load path.\n\n  def load_path_lookup(feature)\n    paths = File.join('{' + @load_path.join(',') + '}', feature + '{' + SUFFIXES + '}')\n    files = Dir.glob(paths)\n    match = files.find{ |f| ! @loaded_features.include?(f) }\n    return match\n  end\n\n  # Loads _file_ into the capsule. Searches relative to the local dir, that is,\n  # the dir of the file given in the original call to\n  # <tt>Capsule.load(file)</tt>, loads the file, if found, into this Capsule's\n  # scope, and returns true. If the file is not found, falls back to\n  # <tt>Kernel.load</tt>, which searches on <tt>$LOAD_PATH</tt>, loads the file,\n  # if found, into global scope, and returns true. Otherwise, raises\n  # <tt>LoadError</tt>.\n  #\n  # The _wrap_ argument is passed to <tt>Kernel.load</tt> in the fallback case,\n  # when the file is not found locally.\n  #\n  # Typically called from within the main file to load additional sub files, or\n  # from those sub files.\n\n  def load(file, wrap = false)\n    file = load_path_lookup(feature)\n    return super unless file\n    load_in_module(file) #File.join(@dir, file))\n    true\n  rescue MissingFile\n    super\n  end\n\n  # Analogous to <tt>Kernel#require</tt>. First tries the local dir, then falls\n  # back to <tt>Kernel#require</tt>. Will load a given _feature_ only once.\n  #\n  # Note that extensions (*.so, *.dll) can be required in the global scope, as\n  # usual, but not in the local scope. (This is not much of a limitation in\n  # practice--you wouldn't want to load an extension more than once.) This\n  # implementation falls back to <tt>Kernel#require</tt> when the argument is an\n  # extension or is not found locally.\n  #\n  #--\n  # TODO: Should this be using #include_script instead?\n  #++\n\n  def require(feature)\n    file = load_path_lookup(feature)\n    return super unless file\n    begin\n      @loaded_features[file] = true\n      load_in_module(file)\n    rescue MissingFile\n      @loaded_features[file] = false\n      super\n    end\n  end\n\n  # Checks the class of each +mods+. If a String, then calls #include_script,\n  # otherwise behaves like normal #include.\n\n  def include(*mods)\n    mods.reverse_each do |mod|\n      case mod\n      when String\n        include_script(mod)\n      else\n        super(mod)\n        extend self if @extend\n      end\n    end\n  end\n\n  # Create a new Capsule for a script and include it into the current capsule.\n\n  def include_script(file)\n    include self.class.new(file, :load_path=>load_path, :loaded_features=>loaded_features, :extend=>false)\n  rescue Errno::ENOENT => e\n    if /#{file}$/ =~ e.message\n      raise MissingFile, e.message\n    else\n      raise\n    end\n    extend self if @extend\n  end\n\n  # Loads _file_ in this module's context. Note that <tt>\\_\\_FILE\\_\\_</tt> and\n  # <tt>\\_\\_LINE\\_\\_</tt> work correctly in _file_.\n  # Called by #load and #require; not normally called directly.\n\n  def load_in_module(file)\n    module_eval(IO.read(file), File.expand_path(file))\n  rescue Errno::ENOENT => e\n    if /#{file}$/ =~ e.message\n      raise MissingFile, e.message\n    else\n      raise\n    end\n  end\n\n  # Give inspection of Capsule with script file name.\n\n  def inspect # :nodoc:\n    \"#<#{self.class}:#{main_file}>\"\n  end\n\n  # Raised by #load_in_module, caught by #load and #require.\n\n  class MissingFile < ::LoadError; end\n\nend\n\n","language":"text/x-ruby"}}
